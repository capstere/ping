Låt mig verifiera båda sakerna systematiskt.​​​​​​​​​​​​​​​​

Granskningen är klar. Här är sammanfattningen:

✅ Installationsflödet — Bekräftat korrekt
Engångsinstallation:

IPTCompile_Install.bat
  → Launcher/Install.bat
    → robocopy nätverksmapp → C:\IPTCompileLauncher\
    → Create-DesktopShortcut.ps1 → "IPTCompile (Local).bat" på skrivbordet


Daglig start (automatiskt):

Skrivbordsgenväg → Run.ps1 (self-update launcher) → Launcher.ps1:
  1. Version.txt ändrad?      → robocopy root (exkl. Modules/Lib)
  2. Modules/*.ps1 ändrad?    → robocopy Modules (exkl. dll/txt/xlsx)
  3. Lib/* ändrad/saknas?     → robocopy Lib
  Allt under .install.lock → Main.ps1 vägrar starta om lock finns


Tre uppdateringstriggers, oberoende av varandra:



|Trigger                                      |Vad kopieras                                 |När                |
|---------------------------------------------|---------------------------------------------|-------------------|
|`Version.txt` bumpad                         |Root-filer (Main.ps1, template, icon)        |Du gör en release  |
|Någon `.ps1` i Modules ändrad (storlek/datum)|Enbart .ps1-filer                            |Du patchar en modul|
|Något i Lib ändrad/saknas                    |Binärer (EPPlus.dll, OpenXml.dll, base64-txt)|Sällan             |

Så ja — du kan bumpa Version.txt eller bara ändra en modul, och Launcher tar hand om resten.

✅ Signeringsfunktioner — Robusta
Seal Test-signering (EPPlus, B47):
	∙	Confirm-SignatureInput → bekräftelsedialog med parsad namn/sign/datum
	∙	_SignSealTestSheets → itererar aktiva datablad via $Layout.SealActiveCheckCell (H3), skriver till $Layout.SignatureCell (B47)
	∙	Hantering: overwrite-skydd, låst fil-varning, separate NEG/POS-räknare, Dispose i finally
Worksheet-signering (OpenXML SDK, ej EPPlus):
	∙	Invoke-WorksheetSignature_OpenXml → öppnar via OpenXML SDK (bevarar namedRanges)
	∙	Stöder 8 flikar i Sammanställning-mode + 1 i Granskning-mode
	∙	DataSummaryGuard, Resample-villkor, label-sökning via Find-FirstRowByContains_OpenXml
	∙	DLL laddas: Lib\ först → Modules\ → NuGet-layout → Base64 fallback
DLL-laddningskedja efter Lib-split:

EPPlus:  $global:LibRoot\EPPlus.dll → $PSScriptRoot\EPPlus.dll → NuGet → Online
OpenXml: $global:LibRoot\DocumentFormat.OpenXml.dll → Modules\ → NuGet layout
         → $global:LibRoot\OpenXMLAssembly.txt → Modules\OpenXMLAssembly.txt


Observation (ej blockerande)
Get-SignatureSetForDataSheets i SignatureHelpers.ps1 rad 60–62 har fortfarande hårdkodade 'H3' och 'B47' istället för $Layout.SealActiveCheckCell/$Layout.SignatureCell. Det fungerar identiskt idag, men om du nån gång ändrar cellposition i $Layout så följer inte den funktionen med. Inte en bugg — bara en notering för framtiden.

Systemet är redo för lansering på torsdag. Lycka till!​​​​​​​​​​​​​​​​














Bra fråga. Det finns en konkret teknisk anledning till uppdelningen, och den är rätt.
Varför Worksheet använder OpenXML SDK:
Kommentaren i OpenXmlHelpers.ps1 rad 1–18 förklarar det — Worksheet-mallarna innehåller definedNames/named ranges som EPPlus 4.5.3.3 skriver om vid Save(). Det triggar Excels reparationsdialogruta: “Removed Records: Named range from /xl/workbook.xml”. OpenXML SDK redigerar bara den specifika sheet-XML:en och lämnar resten orörd.
Varför Seal Test-filerna klarar sig med EPPlus:
Seal Test-filerna (NEG/POS) har en enklare struktur utan problematiska named ranges. EPPlus Save() fungerar utan sidoeffekter där.
Borde du byta till OpenXML SDK för allt?
Det skulle fungera, men jag ser ingen vinst som motiverar arbetet. Du skulle behöva skriva om _SignSealTestSheets (som idag är 15 rader med ren EPPlus-logik) till OpenXML SDK-anrop med Find-FirstRowByContains_OpenXml, Set-OpenXmlCellText, etc. — betydligt mer kod för samma resultat. Dessutom har du redan EPPlus laddat i minnet för CSV-läsning och rapportgenerering, så det kostar ingenting extra att använda det för Seal Test.
Kort svar: Behåll som det är. Uppdelningen är inte en kompromiss — den är rätt verktyg för rätt fil.​​​​​​​​​​​​​​​​


















För framtiden!

Jag vet bara att för framtiden så måste jag justera logiken för följande Assays i RuleBank.compiled.ps1 och RuleEngine.ps1:

Respiratory Panel IUO
Respiratory Panel RUO
Respiratory panel
Respiratory panel CE-IVD
Respiratory panel UKCA-IVD
Xpert GI Panel
GI Panel IUO
GI Panel RUO
Xpert GI Panel CE-IVD

De Assays kan inte gå efter test resultatmönstren i RuleBank.compiled.ps1. Där måste specifika felflaggor tas direkt från Data Summary (och eventuell Resample Data Summary) i Worksheet och "overrule" RuleBank.compiled.ps1 för deras olika target är för komplexa att hårdkoda i mönster. Så de Assay skulle jag behöva göra särskilda undantag för i skriptet.

De kan fortfarabde gå efter RuleBank.compiled i övrigt, men särskilda undantag för "Minor Functional" och "Major Functional". Går det att lösa det på något smart sätt?















Now I understand the flow:
	1.	Classify-Deviation compares Expected vs Observed call (NEG/POS) → returns OK/FP/FN/ERROR/etc.
	2.	For panel assays, the whole result string is matched against RuleBank patterns (EQUALS match of all targets)
	3.	FP/FN counts come from DeviationCounts['FP'] and DeviationCounts['FN']
	4.	MinorFunctionalError comes from ERROR deviations where IsKnownCode is true
For panel assays, the problem is:
	∙	A panel test might have 12 targets NEG + 1 target POS → the EQUALS match fails → the whole test gets flagged, but it’s hard to know if it’s FP or FN at the individual target level
	∙	The Data Summary worksheet already contains “Minor Functional” and “Major Functional” flags in column C from the GeneXpert system itself, so instead of deriving these classifications from the CSV, I should read those flags directly from the output worksheet and use them to override the CSV-based FP/FN/MinorFunctional assignments. I need to check how the build handler populates the Data Summary to understand what column C actually contains
	
	
	
	
	
	
	
	
	
	
	Let me understand this clearly before coding:
	1.	For panel assays (Respiratory/GI), the existing RuleBank pattern matching for test results (NEG/POS EQUALS matching) can’t handle partial target failures
	2.	The Worksheet’s “Data Summary” and “Resample Data Summary” sheets have the actual error classifications in column C, starting from row 10 downward
	3.	These contain literal text “Minor Functional” and “Major Functional”
	4.	For these specific assays, the RuleEngine should NOT derive FP/FN/Minor Functional from CSV pattern matching, but instead read them directly from the Worksheet
Let me look at how the current flow works - specifically how Data Summary is populated and how RuleEngine results flow into the report.
Now I need to trace through the code to see where column C gets its values, how the RuleEngine currently calculates FP/FN/MinorFunctional, and where I can intercept that logic for panel assays.












The user is asking if I think it’s possible to code this. Let me think about what I’ve learned from my analysis.
The key insight is:
	1.	Panel assays (Respiratory/GI) have multi-target results that are too complex for pattern matching in RuleBank
	2.	The Worksheet’s Data Summary already contains the correct “Major Functional” and “Minor Functional” classifications in column C
	3.	The existing Get-DataSummaryFindings function already scans column C and picks up these findings
	4.	BUT the catch-all patterns for *MAJOR FUNCTIONAL* and *MINOR FUNCTIONAL* are commented out in DataSummaryRules
	5.	AND the RuleEngine still classifies FP/FN/ERROR from CSV for these assays, which double-counts or misclassifies
The fix is straightforward: I need to uncomment those catch-all patterns in the config with a Panel scope, then modify the RuleEngine to detect when an assay is a panel type and override any FP/FN classifications to OK with a flag, while also preventing MinorFunctionalError from being counted for panels. This is definitely doable.
The user’s really just asking if it’s feasible, so I should confirm it’s very workable and ask if they want me to move forward with the implementation.











Absolut — det är tre kirurgiska ändringar:
	1.	Config.ps1 — PanelAssays-listan (redan tillagd) + aktivera catch-alls med Scope = 'Panel'
	2.	RuleEngine.ps1 — Efter Classify-Deviation (rad 1646): om assay ∈ PanelAssays och deviation = FP/FN → sätt till OK + flagga PANEL_WS_OVERRIDE. Samma undertryckning i MinorFunctional-räkningen (rad 2073–2087).
	3.	Befintlig infrastruktur gör resten — Get-DataSummaryFindings + scope-systemet plockar redan upp *MAJOR FUNCTIONAL*/*MINOR FUNCTIONAL* från Worksheet kolumn C och visar dem i rapporten.
CSV-data behålls fullt ut (sample numbering, Error/Instrument Error, alla OK-rader) — bara FP/FN/MinorFunctional-klassificeringen lämnas åt Worksheet.
Ska jag köra?​​​​​​​​​​​​​​​​




	
	







Now let me compile all findings and create a patched version. The issues are:
1. 	BUG (Medium): OpenXmlHelpers.ps1 line 33 — OpenXMLAssembly.txt in the DLL candidate list will break the Base64 fallback path if the DLL is missing.

2.	Dead code: Launcher.ps1 has an unused Test-ModulesPs1NeedsUpdate function that’s been superseded by Test-FolderNeedsUpdate, and the try/finally/if nesting around lines 429-433 needs better indentation.
	
















DIFF:


Ja, jag förstår — du vill ha två nya true/false-switchar i Config som gör att menyknapparna för signering fortfarande syns men blir grå/inaktiva (Enabled = $false), istället för att döljas.

Jag har kollat din Main.ps1 i ModulesLib PATCHED och där finns redan:
	•	$miToggleSignSamm / $miToggleSignGransk
	•	de styrs idag med Visible via EnableSignSammanstallning och EnableSignGranskning

Vi lägger till två nya flags som styr Enabled.

⸻

Diff-patch 1: IPTCompile/Modules/Config.ps1

Lägg till flaggorna i FeatureFlags:

*** Begin Patch
*** Update File: IPTCompile/Modules/Config.ps1
@@
     FeatureFlags = @{
         EnableRuleEngine           = $true
         EnableEquipmentSheet       = $true
         EnableRuleEngineDebugSheet = $true
         EnableSharePoint           = $true
+
+        # --- Signering UI ---
+        # Visible (om du vill kunna dölja helt) styrs redan via:
+        #   EnableSignSammanstallning / EnableSignGranskning
+        # Enabled (gråa ut men synlig) styrs av dessa:
+        EnableSignSammanstallningButton = $true
+        EnableSignGranskningButton      = $true
     }
 }
*** End Patch


⸻

Diff-patch 2: IPTCompile/Main.ps1

Precis efter din befintliga Visible-gating (runt raderna där du har EnableSignSammanstallning/EnableSignGranskning), lägg till Enabled + tooltiptext.

*** Begin Patch
*** Update File: IPTCompile/Main.ps1
@@
 # Config-gated: dölj signeringsmenyval om avstängt i Config
 $miToggleSignSamm.Visible   = (Get-ConfigFlag -Name 'EnableSignSammanstallning' -Default $true)
 $miToggleSignGransk.Visible = (Get-ConfigFlag -Name 'EnableSignGranskning' -Default $true)
+
+# Config-gated: gråa ut (Enabled=false) men behåll synlig ("light off")
+$miToggleSignSamm.Enabled   = (Get-ConfigFlag -Name 'EnableSignSammanstallningButton' -Default $true)
+$miToggleSignGransk.Enabled = (Get-ConfigFlag -Name 'EnableSignGranskningButton' -Default $true)
+
+if (-not $miToggleSignSamm.Enabled)   { $miToggleSignSamm.ToolTipText   = 'Avstängt via Config (EnableSignSammanstallningButton=false).' }
+if (-not $miToggleSignGransk.Enabled) { $miToggleSignGransk.ToolTipText = 'Avstängt via Config (EnableSignGranskningButton=false).' }
*** End Patch

Resultat:
	•	EnableSignSammanstallning / EnableSignGranskning = styr synlighet
	•	EnableSignSammanstallningButton / EnableSignGranskningButton = styr grå/inaktiv

⸻

Exempel: stäng av “light” i Config

I din FeatureFlags (eller override om du har en $Config.FeatureFlags), sätt:

EnableSignSammanstallningButton = $false
EnableSignGranskningButton      = $false

Då syns menypunkterna men går inte att klicka på.

⸻

Vill du att “signeringsgruppen” (GroupBox) också ska bli grå om den redan är öppen?
Det är ett extra 2 rader (sätta $grpSignSamm.Enabled / $grpSignGransk.Enabled), men jag ändrar inte det nu utan att du säger att du vill ha exakt det beteendet.










DIFF2: EVENTUELL


Toppen — här är en mini-diff som även gråar ut själva panelen/groupboxen (om den finns) för respektive signering, baserat på samma nya flags.

Jag kan inte se dina exakta variabelnamn för groupboxarna här, så jag gör patchen defensiv: den försöker hitta kontrollerna om de heter vanligt (t.ex. $grpSignSamm, $grpSignGransk, $grpSammanstallningSign, etc.). Om din kod redan har tydliga variabelnamn för dessa, byt bara till rätt namn och ta bort “try”-delarna.

Diff-patch: IPTCompile/Main.ps1

Lägg detta direkt efter blocket där du satte $miToggleSignSamm.Enabled och $miToggleSignGransk.Enabled:

*** Begin Patch
*** Update File: IPTCompile/Main.ps1
@@
 $miToggleSignSamm.Enabled   = (Get-ConfigFlag -Name 'EnableSignSammanstallningButton' -Default $true)
 $miToggleSignGransk.Enabled = (Get-ConfigFlag -Name 'EnableSignGranskningButton' -Default $true)
 
 if (-not $miToggleSignSamm.Enabled)   { $miToggleSignSamm.ToolTipText   = 'Avstängt via Config (EnableSignSammanstallningButton=false).' }
 if (-not $miToggleSignGransk.Enabled) { $miToggleSignGransk.ToolTipText = 'Avstängt via Config (EnableSignGranskningButton=false).' }
+
+# Gråa ut även panel/groupbox (om kontroller finns), så att UI:t känns konsekvent.
+try {
+    $enableSamm = $miToggleSignSamm.Enabled
+    $enableGransk = $miToggleSignGransk.Enabled
+
+    foreach ($n in @('grpSignSamm','grpSammanstallningSign','grpSammanstallning','gbSignSamm')) {
+        if (Get-Variable -Name $n -Scope Script -ErrorAction SilentlyContinue) {
+            $c = (Get-Variable -Name $n -Scope Script).Value
+            if ($c -and $c.PSObject.Properties.Match('Enabled').Count -gt 0) { $c.Enabled = $enableSamm }
+        }
+    }
+    foreach ($n in @('grpSignGransk','grpGranskningSign','grpGranskning','gbSignGransk')) {
+        if (Get-Variable -Name $n -Scope Script -ErrorAction SilentlyContinue) {
+            $c = (Get-Variable -Name $n -Scope Script).Value
+            if ($c -and $c.PSObject.Properties.Match('Enabled').Count -gt 0) { $c.Enabled = $enableGransk }
+        }
+    }
+} catch { }
*** End Patch


⸻

Om du vet dina riktiga kontrollnamn (bäst)

Om du vet att dina groupboxar heter t.ex. $grpSignSamm och $grpSignGransk, så är den här varianten renare (och jag rekommenderar den):

$grpSignSamm.Enabled   = $miToggleSignSamm.Enabled
$grpSignGransk.Enabled = $miToggleSignGransk.Enabled

Säg bara vad de heter i din Main (ctrl-variabelnamnen), så skickar jag en exakt patch utan “fallback-loopar”.












	