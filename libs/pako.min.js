/* Minimal pako-compatible shim (inflateRaw) for offline ClickLess Analyzer.
   Provides: window.pako.inflateRaw(Uint8Array[, expectedSize]) -> Uint8Array
   ES5-compatible, no modules.
*/
(function(global){
  'use strict';

  function BitReader(bytes) {
    this.bytes = bytes;
    this.pos = 0;
    this.bitbuf = 0;
    this.bitcnt = 0;
  }

  BitReader.prototype.readBits = function (n) {
    while (this.bitcnt < n) {
      if (this.pos >= this.bytes.length) throw new Error('Unexpected EOF in bitstream');
      this.bitbuf |= (this.bytes[this.pos++] << this.bitcnt);
      this.bitcnt += 8;
    }
    var val = this.bitbuf & ((1 << n) - 1);
    this.bitbuf >>>= n;
    this.bitcnt -= n;
    return val;
  };

  BitReader.prototype.alignByte = function () {
    this.bitbuf = 0;
    this.bitcnt = 0;
  };

  function buildHuffman(codeLengths) {
    var maxLen = 0;
    for (var i = 0; i < codeLengths.length; i++) if (codeLengths[i] > maxLen) maxLen = codeLengths[i];

    var blCount = new Array(maxLen + 1);
    for (i = 0; i < blCount.length; i++) blCount[i] = 0;

    for (i = 0; i < codeLengths.length; i++) {
      var len = codeLengths[i];
      if (len > 0) blCount[len]++;
    }

    var nextCode = new Array(maxLen + 1);
    var code = 0;
    blCount[0] = 0;
    for (i = 1; i <= maxLen; i++) {
      code = (code + blCount[i - 1]) << 1;
      nextCode[i] = code;
    }

    var root = {};
    for (var sym = 0; sym < codeLengths.length; sym++) {
      var l = codeLengths[sym];
      if (!l) continue;
      var c = nextCode[l]++;
      var node = root;
      for (var bit = l - 1; bit >= 0; bit--) {
        var b = (c >> bit) & 1;
        if (!node[b]) node[b] = {};
        node = node[b];
      }
      node.sym = sym;
    }
    return root;
  }

  function decodeSym(br, tree) {
    var node = tree;
    while (true) {
      var b = br.readBits(1);
      node = node[b];
      if (!node) throw new Error('Bad Huffman code');
      if (node.sym !== undefined) return node.sym;
    }
  }

  var LEN_BASE = [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258];
  var LEN_EXTRA= [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];
  var DIST_BASE=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577];
  var DIST_EXTRA=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

  function fixedLitLenTree() {
    var lengths = new Array(288);
    for (var i = 0; i <= 143; i++) lengths[i] = 8;
    for (i = 144; i <= 255; i++) lengths[i] = 9;
    for (i = 256; i <= 279; i++) lengths[i] = 7;
    for (i = 280; i <= 287; i++) lengths[i] = 8;
    return buildHuffman(lengths);
  }

  function fixedDistTree() {
    var lengths = new Array(32);
    for (var i = 0; i < 32; i++) lengths[i] = 5;
    return buildHuffman(lengths);
  }

  function inflateRaw(compBytes, expectedSize) {
    var br = new BitReader(compBytes);
    var out = [];
    var finalBlock = 0;

    var litTreeFixed = null, distTreeFixed = null;

    while (!finalBlock) {
      finalBlock = br.readBits(1);
      var btype = br.readBits(2);

      if (btype === 0) {
        br.alignByte();
        if (br.pos + 4 > br.bytes.length) throw new Error('Bad stored block');
        var len = br.bytes[br.pos] | (br.bytes[br.pos + 1] << 8);
        var nlen = br.bytes[br.pos + 2] | (br.bytes[br.pos + 3] << 8);
        br.pos += 4;
        if (((len ^ 0xFFFF) & 0xFFFF) !== (nlen & 0xFFFF)) throw new Error('Bad stored block len');
        for (var i = 0; i < len; i++) out.push(br.bytes[br.pos++]);
      } else {
        var litTree, distTree;

        if (btype === 1) {
          if (!litTreeFixed) litTreeFixed = fixedLitLenTree();
          if (!distTreeFixed) distTreeFixed = fixedDistTree();
          litTree = litTreeFixed;
          distTree = distTreeFixed;
        } else if (btype === 2) {
          var HLIT = br.readBits(5) + 257;
          var HDIST = br.readBits(5) + 1;
          var HCLEN = br.readBits(4) + 4;

          var order = [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
          var clen = new Array(19);
          for (var z = 0; z < 19; z++) clen[z] = 0;
          for (z = 0; z < HCLEN; z++) clen[order[z]] = br.readBits(3);
          var clenTree = buildHuffman(clen);

          var all = new Array(HLIT + HDIST);
          var idx = 0;
          while (idx < all.length) {
            var sym = decodeSym(br, clenTree);
            if (sym <= 15) {
              all[idx++] = sym;
            } else if (sym === 16) {
              var repeat = br.readBits(2) + 3;
              var prev = idx ? all[idx - 1] : 0;
              while (repeat-- && idx < all.length) all[idx++] = prev;
            } else if (sym === 17) {
              repeat = br.readBits(3) + 3;
              while (repeat-- && idx < all.length) all[idx++] = 0;
            } else if (sym === 18) {
              repeat = br.readBits(7) + 11;
              while (repeat-- && idx < all.length) all[idx++] = 0;
            } else {
              throw new Error('Bad code length symbol');
            }
          }

          var litLens = all.slice(0, HLIT);
          var distLens = all.slice(HLIT);

          litTree = buildHuffman(litLens);
          distTree = buildHuffman(distLens);
        } else {
          throw new Error('Unsupported block type');
        }

        while (true) {
          var s = decodeSym(br, litTree);
          if (s < 256) {
            out.push(s);
          } else if (s === 256) {
            break;
          } else {
            var li = s - 257;
            var length = LEN_BASE[li] + br.readBits(LEN_EXTRA[li]);

            var ds = decodeSym(br, distTree);
            var dist = DIST_BASE[ds] + br.readBits(DIST_EXTRA[ds]);

            var start = out.length - dist;
            if (start < 0) throw new Error('Bad distance');

            for (var k = 0; k < length; k++) out.push(out[start + k]);
          }
        }
      }
    }

    var u8 = new Uint8Array(out.length);
    for (var j = 0; j < out.length; j++) u8[j] = out[j] & 0xFF;

    if (expectedSize && u8.length !== expectedSize) {
      // keep anyway
    }
    return u8;
  }

  // ----------------------------

  // Expose a pako-like API
  if (!global.pako) global.pako = {};
  if (!global.pako.inflateRaw) {
    global.pako.inflateRaw = function(data, expectedSize){
      return inflateRaw(data, expectedSize);
    };
  }
})(typeof window !== 'undefined' ? window : this);
